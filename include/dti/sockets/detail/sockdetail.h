// -*- c++ -*- 
/*
Copyright (c) 2005 by the Danish Technological Institute.

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

#ifndef SOCKDETAIL_H__DTI_
#define SOCKDETAIL_H__DTI_


namespace dti {
	namespace sockets {
		class tcp_base_socket;
		class tcp_socket;
		class output_formatter;
		class input_formatter;

		namespace detail {
			// The sock_wrapper class encapsulates a socket handle and I/O
			// formatters. It includes a reference count so that the socket will
			// be closed and the formatters deleted when the last reference is
			// deleted. This class is all private because it may only be
			// manipulated by its friends.

			class sock_wrapper {

			  private:
				socket_handle sockhand;	// Socket handle
				int refcount;			// Reference count

				output_formatter *outf;	// Output formatter, if any
				input_formatter *inf; 	// Input formatter, if any
#ifdef _WIN32
				void *abort_recv_event;		// Signal this event to abort recv operation. (void* is the same as WSAEVENT)
				void *abort_send_event;		// Signal this event to abort send operation. (void* is the same as WSAEVENT)
#endif
#ifdef __GNUC__
				int abort_recv_socket;		// Write 1 to this socket to abort recv operation
				int abort_send_socket;		// Write 1 to this socket to abort send operation
#endif
				int recv_abortable(void *buf, std::size_t len, int flags);
				int send_abortable(const void *buf, std::size_t len, int flags);

			  public:
				// CONSTRUCTORS

				// Create from a socket handle (-1 indicates an unopen socket)
				sock_wrapper(socket_handle s = -1);


				// DESTRUCTOR

				~sock_wrapper();


				// METHODS

				// Increment or decrement the reference count
				void inc_refcount();
				int dec_refcount();

				// Create the underlying socket
				void open();
				
				// Is the socket open?
				bool is_open() const;

				// Test if socket is open, throw an exception if not
				void test_open() const;

				// Close the socket handle if it is open
				void close_if_open();

				// Fetch the socket handle
				socket_handle get_socket_handle() const;

				// Read data from the socket, using the input formatter
				int recv_format(void *buf, std::size_t len, int flags);

				// Send data to the socket, using the output formatter
				int send_format(const void *buf, std::size_t len, int flags);

				// Read raw data from the socket
				int recv_noformat(void *buf, std::size_t len, int flags);

				// Send raw data to the socket
				int send_noformat(const void *buf, std::size_t len, int flags);

				// Set an output formatter
				void set_output_formatter(output_formatter *outform);

				// Set an input formatter
				void set_input_formatter(input_formatter *inform);

				// Abort operation, if possible
				void abort();

				// PREVENT COPYING

			  private:
				// Copy constructor. Must not be implemented because
				// this object must never be copied.
				sock_wrapper(sock_wrapper& sw);

				// Assignment operator. Must not be implemented
				// because this object must never be copied.
				const sock_wrapper& operator=(const sock_wrapper& rhs);
			};
		}
	}
}

#endif  /* SOCKDETAIL_H__DTI_ */
